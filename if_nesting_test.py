#!/usr/bin/env python3

'''
Assembly code diagnositic tool.
c2018  Trevor Marvin  GPLv3

This program is for testing the 'IF' nesting in your source code.  It's handy
to use with the interim file generated by the main program in this project
for finding issues related to the nesting limit of the final compiler, which is
16.
'''


import sys, heapq, subprocess, time

ifstack = []
ifnest = []
defines = {}
sections = {}
completed_sections = {}
mpasm_prog = '/opt/microchip/mplabx/v4.20/mpasmx/mpasmx_orig'
inputfilename = '_pre_processed_file.asm'

for entry in sys.argv[1:]:
  if entry[:1] == '-':
    continue
  inputfilename = entry
  break

# -----------------------------------------------------------------------------
def test_ifnest(line, filename, count):
  
  global ifnest
  
  ifnest.append((line, filename, count))
  if len(ifstack) > 15:
    print('nesting depth at ' + str(len(ifstack)) + ' in ' + filename + \
          ' at line ' + str(count), file=sys.stderr)
    for line, filename, count in ifnest:
      print('- file: ' + filename + ':' + str(count) + ' ' + line, \
            file=sys.stderr)


# -----------------------------------------------
def parse_file(infile, filename):
  
  global ifstack, ifnest, defines, sections
  
  #for count, line in enumerate(infile.readlines()):
  count = -1
  while True:
    count += 1
    line = infile.readline()
    if len(line) == 0:
      break
    
    if ';' in line:
      pieces = line.split(';', 1)[0].split()  # remove comment
    else:
      pieces = line.split()
    
    if len(pieces) == 0:
      continue
    keyword = pieces[0].lower()
    
    if keyword in ['#ifdef', '#ifndef', '#define', '#undefine', '#include',
                   '#insert', '#section', ] and len(pieces) < 2:
      print('PRE-PREPROCESSOR: not enough arguments in ' + filename + \
            ' at line ' + str(count + 1), file=sys.stderr)
      print('- line: ' + line, file=sys.stderr)
      sys.exit(1)
    
    if keyword == '#endif':
      if len(ifstack) == 0:
        print('unmatched ENDIF directive in ' + filename, file=sys.stderr)
        sys.exit(1)
      ifstack.pop()
      ifnest.pop()
      continue

    if keyword == '#else':
      if len(ifstack) == 0:
        print('unmatched ELSE directive in ' + filename + \
              ' at line ' + str(count), file=sys.stderr)
        sys.exit(1)
      index = len(ifstack) - 1
      if ifstack[index] is True:
        ifstack[index] = False
      elif ifstack[index] is False:
        ifstack[index] = True
    
    if keyword == '#if':
      ifstack.append(None)
      test_ifnest(line.strip(), filename, count)
      continue
    
    if keyword == '#ifdef':
      if pieces[1].lower() in defines:
        ifstack.append(True)
      else:
        ifstack.append(False)
      test_ifnest(line.strip(), filename, count)
      continue
    
    if keyword == '#ifndef':
      if pieces[1].lower() in defines:
        ifstack.append(False)
      else:
        ifstack.append(True)
      test_ifnest(line.strip(), filename, count)
      continue
    
    if keyword == '#define':
      if len(pieces) > 2:
        defines[pieces[1].lower()] = pieces[2]
      else:
        defines[pieces[1].lower()] = None
      continue

    # special case for catching 'set' and 'equ' function
    if (len(pieces) > 2) and (pieces[1].lower() in ['set', 'equ', ]):
      value = ' '.join(pieces[2:]).strip()
      if ';' in value:
        value = value.split(';')[0].strip()
      defines[pieces[0].lower()] = value
      continue

    if keyword == '#undefine':
      if pieces[1].lower() in defines:
        del defines[pieces[1].lower()]
      continue
    
    if keyword == '#include':
      if len(ifstack) > 0 and False in ifstack:
        # conditional says to not include it
        print('skipping included file ' + filename + \
              ' due to conditional ' + str(count), file=sys.stderr)
        print('- ' + str(ifstack))
        print('- ' + line.strip())
        continue
      recfn = pieces[1]
      if recfn[:1] == '<':
        recfn = recfn[1:-1]
      try:
        recfile = open(recfn, 'r')
      except Exception as msg:
        print('PRE WARNING: failed to open include file: ' + recfn, file=sys.stderr)
        continue
      # scan the file for "INSERT" and "SECTION" directives, skip if none are in there
      stack_balance = len(ifstack)
      parse_file(recfile, recfn)
      if len(ifstack) != stack_balance:
        print('conditional stack length altered after INCLUDE directive ' + \
              'in file: ' + recfn, file=sys.stderr)
      recfile.close()
      continue
    
  infile.close()
    
    
# -----------------------------------------------------------------------------

if not inputfilename:
  print("no file specified")
  sys.exit(1)

# the filename is coming in with quotes on it
if inputfilename[:1] == '"':
  inputfilename = inputfilename.strip('"')

try:
  infile = open(inputfilename, 'r')
except Exception as msg:
  print("failed to import file, error: " + str(msg))
  print("failed to import file: " + str(inputfilename))
  sys.exit(1)

parse_file(infile, inputfilename)
